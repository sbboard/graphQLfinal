// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  character: (where?: CharacterWhereInput) => Promise<boolean>;
  movements: (where?: MovementsWhereInput) => Promise<boolean>;
  moves: (where?: MovesWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  character: (where: CharacterWhereUniqueInput) => CharacterPromise;
  characters: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Character>;
  charactersConnection: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterConnectionPromise;
  movements: (where: MovementsWhereUniqueInput) => MovementsPromise;
  movementses: (
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Movements>;
  movementsesConnection: (
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MovementsConnectionPromise;
  moves: (where: MovesWhereUniqueInput) => MovesPromise;
  moveses: (
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Moves>;
  movesesConnection: (
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MovesConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharacter: (data: CharacterCreateInput) => CharacterPromise;
  updateCharacter: (
    args: { data: CharacterUpdateInput; where: CharacterWhereUniqueInput }
  ) => CharacterPromise;
  updateManyCharacters: (
    args: {
      data: CharacterUpdateManyMutationInput;
      where?: CharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacter: (
    args: {
      where: CharacterWhereUniqueInput;
      create: CharacterCreateInput;
      update: CharacterUpdateInput;
    }
  ) => CharacterPromise;
  deleteCharacter: (where: CharacterWhereUniqueInput) => CharacterPromise;
  deleteManyCharacters: (where?: CharacterWhereInput) => BatchPayloadPromise;
  createMovements: (data: MovementsCreateInput) => MovementsPromise;
  updateMovements: (
    args: { data: MovementsUpdateInput; where: MovementsWhereUniqueInput }
  ) => MovementsPromise;
  updateManyMovementses: (
    args: {
      data: MovementsUpdateManyMutationInput;
      where?: MovementsWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMovements: (
    args: {
      where: MovementsWhereUniqueInput;
      create: MovementsCreateInput;
      update: MovementsUpdateInput;
    }
  ) => MovementsPromise;
  deleteMovements: (where: MovementsWhereUniqueInput) => MovementsPromise;
  deleteManyMovementses: (where?: MovementsWhereInput) => BatchPayloadPromise;
  createMoves: (data: MovesCreateInput) => MovesPromise;
  updateMoves: (
    args: { data: MovesUpdateInput; where: MovesWhereUniqueInput }
  ) => MovesPromise;
  updateManyMoveses: (
    args: { data: MovesUpdateManyMutationInput; where?: MovesWhereInput }
  ) => BatchPayloadPromise;
  upsertMoves: (
    args: {
      where: MovesWhereUniqueInput;
      create: MovesCreateInput;
      update: MovesUpdateInput;
    }
  ) => MovesPromise;
  deleteMoves: (where: MovesWhereUniqueInput) => MovesPromise;
  deleteManyMoveses: (where?: MovesWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  character: (
    where?: CharacterSubscriptionWhereInput
  ) => CharacterSubscriptionPayloadSubscription;
  movements: (
    where?: MovementsSubscriptionWhereInput
  ) => MovementsSubscriptionPayloadSubscription;
  moves: (
    where?: MovesSubscriptionWhereInput
  ) => MovesSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MovesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "hitBoxActive_ASC"
  | "hitBoxActive_DESC"
  | "firstActionableFrame_ASC"
  | "firstActionableFrame_DESC"
  | "baseDmg_ASC"
  | "baseDmg_DESC"
  | "angle_ASC"
  | "angle_DESC"
  | "baseKnockBackSetKnockback_ASC"
  | "baseKnockBackSetKnockback_DESC"
  | "landingLag_ASC"
  | "landingLag_DESC"
  | "autoCancel_ASC"
  | "autoCancel_DESC"
  | "knockbackGrowth_ASC"
  | "knockbackGrowth_DESC"
  | "moveType_ASC"
  | "moveType_DESC"
  | "isWeightDependent_ASC"
  | "isWeightDependent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "mainImgUrl_ASC"
  | "mainImgUrl_DESC"
  | "thumbnailImg_ASC"
  | "thumbnailImg_DESC"
  | "colorTheme_ASC"
  | "colorTheme_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MovementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "maxJumps_ASC"
  | "maxJumps_DESC"
  | "runSpeed_ASC"
  | "runSpeed_DESC"
  | "wallJump_ASC"
  | "wallJump_DESC"
  | "walkSpeed_ASC"
  | "walkSpeed_DESC"
  | "wallCling_ASC"
  | "wallCling_DESC"
  | "airSpeed_ASC"
  | "airSpeed_DESC"
  | "crawl_ASC"
  | "crawl_DESC"
  | "fallSpeed_ASC"
  | "fallSpeed_DESC"
  | "tether_ASC"
  | "tether_DESC"
  | "fastFallSpeed_ASC"
  | "fastFallSpeed_DESC"
  | "jumpSquat_ASC"
  | "jumpSquat_DESC"
  | "airAcceleration_ASC"
  | "airAcceleration_DESC"
  | "softLandingLag_ASC"
  | "softLandingLag_DESC"
  | "gravity_ASC"
  | "gravity_DESC"
  | "hardLandingLag_ASC"
  | "hardLandingLag_DESC"
  | "shAirTime_ASC"
  | "shAirTime_DESC"
  | "fhAirTime_ASC"
  | "fhAirTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface MovesUpsertWithWhereUniqueWithoutUserInput {
  where: MovesWhereUniqueInput;
  update: MovesUpdateWithoutUserDataInput;
  create: MovesCreateWithoutUserInput;
}

export type CharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface MovesUpdateManyDataInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovementsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: CharacterWhereInput;
  weight?: Int;
  weight_not?: Int;
  weight_in?: Int[] | Int;
  weight_not_in?: Int[] | Int;
  weight_lt?: Int;
  weight_lte?: Int;
  weight_gt?: Int;
  weight_gte?: Int;
  maxJumps?: Int;
  maxJumps_not?: Int;
  maxJumps_in?: Int[] | Int;
  maxJumps_not_in?: Int[] | Int;
  maxJumps_lt?: Int;
  maxJumps_lte?: Int;
  maxJumps_gt?: Int;
  maxJumps_gte?: Int;
  runSpeed?: Int;
  runSpeed_not?: Int;
  runSpeed_in?: Int[] | Int;
  runSpeed_not_in?: Int[] | Int;
  runSpeed_lt?: Int;
  runSpeed_lte?: Int;
  runSpeed_gt?: Int;
  runSpeed_gte?: Int;
  wallJump?: Boolean;
  wallJump_not?: Boolean;
  walkSpeed?: Int;
  walkSpeed_not?: Int;
  walkSpeed_in?: Int[] | Int;
  walkSpeed_not_in?: Int[] | Int;
  walkSpeed_lt?: Int;
  walkSpeed_lte?: Int;
  walkSpeed_gt?: Int;
  walkSpeed_gte?: Int;
  wallCling?: Boolean;
  wallCling_not?: Boolean;
  airSpeed?: Int;
  airSpeed_not?: Int;
  airSpeed_in?: Int[] | Int;
  airSpeed_not_in?: Int[] | Int;
  airSpeed_lt?: Int;
  airSpeed_lte?: Int;
  airSpeed_gt?: Int;
  airSpeed_gte?: Int;
  crawl?: Boolean;
  crawl_not?: Boolean;
  fallSpeed?: Int;
  fallSpeed_not?: Int;
  fallSpeed_in?: Int[] | Int;
  fallSpeed_not_in?: Int[] | Int;
  fallSpeed_lt?: Int;
  fallSpeed_lte?: Int;
  fallSpeed_gt?: Int;
  fallSpeed_gte?: Int;
  tether?: Boolean;
  tether_not?: Boolean;
  fastFallSpeed?: Int;
  fastFallSpeed_not?: Int;
  fastFallSpeed_in?: Int[] | Int;
  fastFallSpeed_not_in?: Int[] | Int;
  fastFallSpeed_lt?: Int;
  fastFallSpeed_lte?: Int;
  fastFallSpeed_gt?: Int;
  fastFallSpeed_gte?: Int;
  jumpSquat?: String;
  jumpSquat_not?: String;
  jumpSquat_in?: String[] | String;
  jumpSquat_not_in?: String[] | String;
  jumpSquat_lt?: String;
  jumpSquat_lte?: String;
  jumpSquat_gt?: String;
  jumpSquat_gte?: String;
  jumpSquat_contains?: String;
  jumpSquat_not_contains?: String;
  jumpSquat_starts_with?: String;
  jumpSquat_not_starts_with?: String;
  jumpSquat_ends_with?: String;
  jumpSquat_not_ends_with?: String;
  airAcceleration?: Int;
  airAcceleration_not?: Int;
  airAcceleration_in?: Int[] | Int;
  airAcceleration_not_in?: Int[] | Int;
  airAcceleration_lt?: Int;
  airAcceleration_lte?: Int;
  airAcceleration_gt?: Int;
  airAcceleration_gte?: Int;
  softLandingLag?: String;
  softLandingLag_not?: String;
  softLandingLag_in?: String[] | String;
  softLandingLag_not_in?: String[] | String;
  softLandingLag_lt?: String;
  softLandingLag_lte?: String;
  softLandingLag_gt?: String;
  softLandingLag_gte?: String;
  softLandingLag_contains?: String;
  softLandingLag_not_contains?: String;
  softLandingLag_starts_with?: String;
  softLandingLag_not_starts_with?: String;
  softLandingLag_ends_with?: String;
  softLandingLag_not_ends_with?: String;
  gravity?: Int;
  gravity_not?: Int;
  gravity_in?: Int[] | Int;
  gravity_not_in?: Int[] | Int;
  gravity_lt?: Int;
  gravity_lte?: Int;
  gravity_gt?: Int;
  gravity_gte?: Int;
  hardLandingLag?: String;
  hardLandingLag_not?: String;
  hardLandingLag_in?: String[] | String;
  hardLandingLag_not_in?: String[] | String;
  hardLandingLag_lt?: String;
  hardLandingLag_lte?: String;
  hardLandingLag_gt?: String;
  hardLandingLag_gte?: String;
  hardLandingLag_contains?: String;
  hardLandingLag_not_contains?: String;
  hardLandingLag_starts_with?: String;
  hardLandingLag_not_starts_with?: String;
  hardLandingLag_ends_with?: String;
  hardLandingLag_not_ends_with?: String;
  shAirTime?: String;
  shAirTime_not?: String;
  shAirTime_in?: String[] | String;
  shAirTime_not_in?: String[] | String;
  shAirTime_lt?: String;
  shAirTime_lte?: String;
  shAirTime_gt?: String;
  shAirTime_gte?: String;
  shAirTime_contains?: String;
  shAirTime_not_contains?: String;
  shAirTime_starts_with?: String;
  shAirTime_not_starts_with?: String;
  shAirTime_ends_with?: String;
  shAirTime_not_ends_with?: String;
  fhAirTime?: String;
  fhAirTime_not?: String;
  fhAirTime_in?: String[] | String;
  fhAirTime_not_in?: String[] | String;
  fhAirTime_lt?: String;
  fhAirTime_lte?: String;
  fhAirTime_gt?: String;
  fhAirTime_gte?: String;
  fhAirTime_contains?: String;
  fhAirTime_not_contains?: String;
  fhAirTime_starts_with?: String;
  fhAirTime_not_starts_with?: String;
  fhAirTime_ends_with?: String;
  fhAirTime_not_ends_with?: String;
  AND?: MovementsWhereInput[] | MovementsWhereInput;
  OR?: MovementsWhereInput[] | MovementsWhereInput;
  NOT?: MovementsWhereInput[] | MovementsWhereInput;
}

export interface MovesCreateManyWithoutUserInput {
  create?: MovesCreateWithoutUserInput[] | MovesCreateWithoutUserInput;
  connect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
}

export interface CharacterCreateOneWithoutMovementsInfoInput {
  create?: CharacterCreateWithoutMovementsInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface MovesCreateWithoutUserInput {
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovementsUpdateOneWithoutUserInput {
  create?: MovementsCreateWithoutUserInput;
  update?: MovementsUpdateWithoutUserDataInput;
  upsert?: MovementsUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MovementsWhereUniqueInput;
}

export interface MovementsCreateOneWithoutUserInput {
  create?: MovementsCreateWithoutUserInput;
  connect?: MovementsWhereUniqueInput;
}

export interface MovementsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MovementsWhereInput;
  AND?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
  OR?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
  NOT?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
}

export interface MovementsCreateWithoutUserInput {
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface CharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterWhereInput;
  AND?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  OR?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  NOT?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
}

export interface CharacterUpdateInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesUpdateManyWithoutUserInput;
  movementsInfo?: MovementsUpdateOneWithoutUserInput;
}

export interface CharacterUpsertWithoutMoveInfoInput {
  update: CharacterUpdateWithoutMoveInfoDataInput;
  create: CharacterCreateWithoutMoveInfoInput;
}

export interface MovesUpdateManyWithoutUserInput {
  create?: MovesCreateWithoutUserInput[] | MovesCreateWithoutUserInput;
  delete?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  connect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  set?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  disconnect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  update?:
    | MovesUpdateWithWhereUniqueWithoutUserInput[]
    | MovesUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | MovesUpsertWithWhereUniqueWithoutUserInput[]
    | MovesUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  updateMany?:
    | MovesUpdateManyWithWhereNestedInput[]
    | MovesUpdateManyWithWhereNestedInput;
}

export type MovementsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MovesUpdateWithWhereUniqueWithoutUserInput {
  where: MovesWhereUniqueInput;
  data: MovesUpdateWithoutUserDataInput;
}

export interface MovesUpdateInput {
  name?: String;
  user?: CharacterUpdateOneRequiredWithoutMoveInfoInput;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesUpdateWithoutUserDataInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface CharacterCreateOneWithoutMoveInfoInput {
  create?: CharacterCreateWithoutMoveInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface CharacterUpdateWithoutMovementsInfoDataInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesUpdateManyWithoutUserInput;
}

export interface MovesCreateInput {
  name: String;
  user: CharacterCreateOneWithoutMoveInfoInput;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  hitBoxActive?: String;
  hitBoxActive_not?: String;
  hitBoxActive_in?: String[] | String;
  hitBoxActive_not_in?: String[] | String;
  hitBoxActive_lt?: String;
  hitBoxActive_lte?: String;
  hitBoxActive_gt?: String;
  hitBoxActive_gte?: String;
  hitBoxActive_contains?: String;
  hitBoxActive_not_contains?: String;
  hitBoxActive_starts_with?: String;
  hitBoxActive_not_starts_with?: String;
  hitBoxActive_ends_with?: String;
  hitBoxActive_not_ends_with?: String;
  firstActionableFrame?: Int;
  firstActionableFrame_not?: Int;
  firstActionableFrame_in?: Int[] | Int;
  firstActionableFrame_not_in?: Int[] | Int;
  firstActionableFrame_lt?: Int;
  firstActionableFrame_lte?: Int;
  firstActionableFrame_gt?: Int;
  firstActionableFrame_gte?: Int;
  baseDmg?: Int;
  baseDmg_not?: Int;
  baseDmg_in?: Int[] | Int;
  baseDmg_not_in?: Int[] | Int;
  baseDmg_lt?: Int;
  baseDmg_lte?: Int;
  baseDmg_gt?: Int;
  baseDmg_gte?: Int;
  angle?: Int;
  angle_not?: Int;
  angle_in?: Int[] | Int;
  angle_not_in?: Int[] | Int;
  angle_lt?: Int;
  angle_lte?: Int;
  angle_gt?: Int;
  angle_gte?: Int;
  baseKnockBackSetKnockback?: Int;
  baseKnockBackSetKnockback_not?: Int;
  baseKnockBackSetKnockback_in?: Int[] | Int;
  baseKnockBackSetKnockback_not_in?: Int[] | Int;
  baseKnockBackSetKnockback_lt?: Int;
  baseKnockBackSetKnockback_lte?: Int;
  baseKnockBackSetKnockback_gt?: Int;
  baseKnockBackSetKnockback_gte?: Int;
  landingLag?: Int;
  landingLag_not?: Int;
  landingLag_in?: Int[] | Int;
  landingLag_not_in?: Int[] | Int;
  landingLag_lt?: Int;
  landingLag_lte?: Int;
  landingLag_gt?: Int;
  landingLag_gte?: Int;
  autoCancel?: String;
  autoCancel_not?: String;
  autoCancel_in?: String[] | String;
  autoCancel_not_in?: String[] | String;
  autoCancel_lt?: String;
  autoCancel_lte?: String;
  autoCancel_gt?: String;
  autoCancel_gte?: String;
  autoCancel_contains?: String;
  autoCancel_not_contains?: String;
  autoCancel_starts_with?: String;
  autoCancel_not_starts_with?: String;
  autoCancel_ends_with?: String;
  autoCancel_not_ends_with?: String;
  knockbackGrowth?: Int;
  knockbackGrowth_not?: Int;
  knockbackGrowth_in?: Int[] | Int;
  knockbackGrowth_not_in?: Int[] | Int;
  knockbackGrowth_lt?: Int;
  knockbackGrowth_lte?: Int;
  knockbackGrowth_gt?: Int;
  knockbackGrowth_gte?: Int;
  moveType?: String;
  moveType_not?: String;
  moveType_in?: String[] | String;
  moveType_not_in?: String[] | String;
  moveType_lt?: String;
  moveType_lte?: String;
  moveType_gt?: String;
  moveType_gte?: String;
  moveType_contains?: String;
  moveType_not_contains?: String;
  moveType_starts_with?: String;
  moveType_not_starts_with?: String;
  moveType_ends_with?: String;
  moveType_not_ends_with?: String;
  isWeightDependent?: Boolean;
  isWeightDependent_not?: Boolean;
  AND?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  OR?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  NOT?: MovesScalarWhereInput[] | MovesScalarWhereInput;
}

export interface CharacterUpsertWithoutMovementsInfoInput {
  update: CharacterUpdateWithoutMovementsInfoDataInput;
  create: CharacterCreateWithoutMovementsInfoInput;
}

export interface MovesUpdateManyWithWhereNestedInput {
  where: MovesScalarWhereInput;
  data: MovesUpdateManyDataInput;
}

export interface CharacterCreateInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesCreateManyWithoutUserInput;
  movementsInfo?: MovementsCreateOneWithoutUserInput;
}

export interface CharacterUpdateOneRequiredWithoutMovementsInfoInput {
  create?: CharacterCreateWithoutMovementsInfoInput;
  update?: CharacterUpdateWithoutMovementsInfoDataInput;
  upsert?: CharacterUpsertWithoutMovementsInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface MovesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: CharacterWhereInput;
  hitBoxActive?: String;
  hitBoxActive_not?: String;
  hitBoxActive_in?: String[] | String;
  hitBoxActive_not_in?: String[] | String;
  hitBoxActive_lt?: String;
  hitBoxActive_lte?: String;
  hitBoxActive_gt?: String;
  hitBoxActive_gte?: String;
  hitBoxActive_contains?: String;
  hitBoxActive_not_contains?: String;
  hitBoxActive_starts_with?: String;
  hitBoxActive_not_starts_with?: String;
  hitBoxActive_ends_with?: String;
  hitBoxActive_not_ends_with?: String;
  firstActionableFrame?: Int;
  firstActionableFrame_not?: Int;
  firstActionableFrame_in?: Int[] | Int;
  firstActionableFrame_not_in?: Int[] | Int;
  firstActionableFrame_lt?: Int;
  firstActionableFrame_lte?: Int;
  firstActionableFrame_gt?: Int;
  firstActionableFrame_gte?: Int;
  baseDmg?: Int;
  baseDmg_not?: Int;
  baseDmg_in?: Int[] | Int;
  baseDmg_not_in?: Int[] | Int;
  baseDmg_lt?: Int;
  baseDmg_lte?: Int;
  baseDmg_gt?: Int;
  baseDmg_gte?: Int;
  angle?: Int;
  angle_not?: Int;
  angle_in?: Int[] | Int;
  angle_not_in?: Int[] | Int;
  angle_lt?: Int;
  angle_lte?: Int;
  angle_gt?: Int;
  angle_gte?: Int;
  baseKnockBackSetKnockback?: Int;
  baseKnockBackSetKnockback_not?: Int;
  baseKnockBackSetKnockback_in?: Int[] | Int;
  baseKnockBackSetKnockback_not_in?: Int[] | Int;
  baseKnockBackSetKnockback_lt?: Int;
  baseKnockBackSetKnockback_lte?: Int;
  baseKnockBackSetKnockback_gt?: Int;
  baseKnockBackSetKnockback_gte?: Int;
  landingLag?: Int;
  landingLag_not?: Int;
  landingLag_in?: Int[] | Int;
  landingLag_not_in?: Int[] | Int;
  landingLag_lt?: Int;
  landingLag_lte?: Int;
  landingLag_gt?: Int;
  landingLag_gte?: Int;
  autoCancel?: String;
  autoCancel_not?: String;
  autoCancel_in?: String[] | String;
  autoCancel_not_in?: String[] | String;
  autoCancel_lt?: String;
  autoCancel_lte?: String;
  autoCancel_gt?: String;
  autoCancel_gte?: String;
  autoCancel_contains?: String;
  autoCancel_not_contains?: String;
  autoCancel_starts_with?: String;
  autoCancel_not_starts_with?: String;
  autoCancel_ends_with?: String;
  autoCancel_not_ends_with?: String;
  knockbackGrowth?: Int;
  knockbackGrowth_not?: Int;
  knockbackGrowth_in?: Int[] | Int;
  knockbackGrowth_not_in?: Int[] | Int;
  knockbackGrowth_lt?: Int;
  knockbackGrowth_lte?: Int;
  knockbackGrowth_gt?: Int;
  knockbackGrowth_gte?: Int;
  moveType?: String;
  moveType_not?: String;
  moveType_in?: String[] | String;
  moveType_not_in?: String[] | String;
  moveType_lt?: String;
  moveType_lte?: String;
  moveType_gt?: String;
  moveType_gte?: String;
  moveType_contains?: String;
  moveType_not_contains?: String;
  moveType_starts_with?: String;
  moveType_not_starts_with?: String;
  moveType_ends_with?: String;
  moveType_not_ends_with?: String;
  isWeightDependent?: Boolean;
  isWeightDependent_not?: Boolean;
  AND?: MovesWhereInput[] | MovesWhereInput;
  OR?: MovesWhereInput[] | MovesWhereInput;
  NOT?: MovesWhereInput[] | MovesWhereInput;
}

export interface CharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  displayName?: String;
  displayName_not?: String;
  displayName_in?: String[] | String;
  displayName_not_in?: String[] | String;
  displayName_lt?: String;
  displayName_lte?: String;
  displayName_gt?: String;
  displayName_gte?: String;
  displayName_contains?: String;
  displayName_not_contains?: String;
  displayName_starts_with?: String;
  displayName_not_starts_with?: String;
  displayName_ends_with?: String;
  displayName_not_ends_with?: String;
  mainImgUrl?: String;
  mainImgUrl_not?: String;
  mainImgUrl_in?: String[] | String;
  mainImgUrl_not_in?: String[] | String;
  mainImgUrl_lt?: String;
  mainImgUrl_lte?: String;
  mainImgUrl_gt?: String;
  mainImgUrl_gte?: String;
  mainImgUrl_contains?: String;
  mainImgUrl_not_contains?: String;
  mainImgUrl_starts_with?: String;
  mainImgUrl_not_starts_with?: String;
  mainImgUrl_ends_with?: String;
  mainImgUrl_not_ends_with?: String;
  thumbnailImg?: String;
  thumbnailImg_not?: String;
  thumbnailImg_in?: String[] | String;
  thumbnailImg_not_in?: String[] | String;
  thumbnailImg_lt?: String;
  thumbnailImg_lte?: String;
  thumbnailImg_gt?: String;
  thumbnailImg_gte?: String;
  thumbnailImg_contains?: String;
  thumbnailImg_not_contains?: String;
  thumbnailImg_starts_with?: String;
  thumbnailImg_not_starts_with?: String;
  thumbnailImg_ends_with?: String;
  thumbnailImg_not_ends_with?: String;
  colorTheme?: String;
  colorTheme_not?: String;
  colorTheme_in?: String[] | String;
  colorTheme_not_in?: String[] | String;
  colorTheme_lt?: String;
  colorTheme_lte?: String;
  colorTheme_gt?: String;
  colorTheme_gte?: String;
  colorTheme_contains?: String;
  colorTheme_not_contains?: String;
  colorTheme_starts_with?: String;
  colorTheme_not_starts_with?: String;
  colorTheme_ends_with?: String;
  colorTheme_not_ends_with?: String;
  moveInfo_every?: MovesWhereInput;
  moveInfo_some?: MovesWhereInput;
  moveInfo_none?: MovesWhereInput;
  movementsInfo?: MovementsWhereInput;
  AND?: CharacterWhereInput[] | CharacterWhereInput;
  OR?: CharacterWhereInput[] | CharacterWhereInput;
  NOT?: CharacterWhereInput[] | CharacterWhereInput;
}

export interface CharacterUpdateWithoutMoveInfoDataInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  movementsInfo?: MovementsUpdateOneWithoutUserInput;
}

export interface MovementsUpdateWithoutUserDataInput {
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface CharacterCreateWithoutMoveInfoInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  movementsInfo?: MovementsCreateOneWithoutUserInput;
}

export interface MovementsUpsertWithoutUserInput {
  update: MovementsUpdateWithoutUserDataInput;
  create: MovementsCreateWithoutUserInput;
}

export interface MovementsUpdateManyMutationInput {
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface MovesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MovesWhereInput;
  AND?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
  OR?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
  NOT?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
}

export interface MovementsCreateInput {
  user: CharacterCreateOneWithoutMovementsInfoInput;
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface CharacterCreateWithoutMovementsInfoInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesCreateManyWithoutUserInput;
}

export interface MovementsUpdateInput {
  user?: CharacterUpdateOneRequiredWithoutMovementsInfoInput;
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface CharacterUpdateManyMutationInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export interface MovesUpdateManyMutationInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export type MovesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CharacterUpdateOneRequiredWithoutMoveInfoInput {
  create?: CharacterCreateWithoutMoveInfoInput;
  update?: CharacterUpdateWithoutMoveInfoDataInput;
  upsert?: CharacterUpsertWithoutMoveInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface MovesPreviousValues {
  id: ID_Output;
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesPreviousValuesPromise
  extends Promise<MovesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hitBoxActive: () => Promise<String>;
  firstActionableFrame: () => Promise<Int>;
  baseDmg: () => Promise<Int>;
  angle: () => Promise<Int>;
  baseKnockBackSetKnockback: () => Promise<Int>;
  landingLag: () => Promise<Int>;
  autoCancel: () => Promise<String>;
  knockbackGrowth: () => Promise<Int>;
  moveType: () => Promise<String>;
  isWeightDependent: () => Promise<Boolean>;
}

export interface MovesPreviousValuesSubscription
  extends Promise<AsyncIterator<MovesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hitBoxActive: () => Promise<AsyncIterator<String>>;
  firstActionableFrame: () => Promise<AsyncIterator<Int>>;
  baseDmg: () => Promise<AsyncIterator<Int>>;
  angle: () => Promise<AsyncIterator<Int>>;
  baseKnockBackSetKnockback: () => Promise<AsyncIterator<Int>>;
  landingLag: () => Promise<AsyncIterator<Int>>;
  autoCancel: () => Promise<AsyncIterator<String>>;
  knockbackGrowth: () => Promise<AsyncIterator<Int>>;
  moveType: () => Promise<AsyncIterator<String>>;
  isWeightDependent: () => Promise<AsyncIterator<Boolean>>;
}

export interface Character {
  id: ID_Output;
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export interface CharacterPromise extends Promise<Character>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  displayName: () => Promise<String>;
  mainImgUrl: () => Promise<String>;
  thumbnailImg: () => Promise<String>;
  colorTheme: () => Promise<String>;
  moveInfo: <T = FragmentableArray<Moves>>(
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  movementsInfo: <T = MovementsPromise>() => T;
}

export interface CharacterSubscription
  extends Promise<AsyncIterator<Character>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  mainImgUrl: () => Promise<AsyncIterator<String>>;
  thumbnailImg: () => Promise<AsyncIterator<String>>;
  colorTheme: () => Promise<AsyncIterator<String>>;
  moveInfo: <T = Promise<AsyncIterator<MovesSubscription>>>(
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  movementsInfo: <T = MovementsSubscription>() => T;
}

export interface MovementsSubscriptionPayload {
  mutation: MutationType;
  node: Movements;
  updatedFields: String[];
  previousValues: MovementsPreviousValues;
}

export interface MovementsSubscriptionPayloadPromise
  extends Promise<MovementsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovementsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovementsPreviousValuesPromise>() => T;
}

export interface MovementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovementsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovementsPreviousValuesSubscription>() => T;
}

export interface AggregateCharacter {
  count: Int;
}

export interface AggregateCharacterPromise
  extends Promise<AggregateCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterSubscription
  extends Promise<AsyncIterator<AggregateCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharacterEdge {
  node: Character;
  cursor: String;
}

export interface CharacterEdgePromise
  extends Promise<CharacterEdge>,
    Fragmentable {
  node: <T = CharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterEdgeSubscription
  extends Promise<AsyncIterator<CharacterEdge>>,
    Fragmentable {
  node: <T = CharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Moves {
  id: ID_Output;
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesPromise extends Promise<Moves>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  user: <T = CharacterPromise>() => T;
  hitBoxActive: () => Promise<String>;
  firstActionableFrame: () => Promise<Int>;
  baseDmg: () => Promise<Int>;
  angle: () => Promise<Int>;
  baseKnockBackSetKnockback: () => Promise<Int>;
  landingLag: () => Promise<Int>;
  autoCancel: () => Promise<String>;
  knockbackGrowth: () => Promise<Int>;
  moveType: () => Promise<String>;
  isWeightDependent: () => Promise<Boolean>;
}

export interface MovesSubscription
  extends Promise<AsyncIterator<Moves>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = CharacterSubscription>() => T;
  hitBoxActive: () => Promise<AsyncIterator<String>>;
  firstActionableFrame: () => Promise<AsyncIterator<Int>>;
  baseDmg: () => Promise<AsyncIterator<Int>>;
  angle: () => Promise<AsyncIterator<Int>>;
  baseKnockBackSetKnockback: () => Promise<AsyncIterator<Int>>;
  landingLag: () => Promise<AsyncIterator<Int>>;
  autoCancel: () => Promise<AsyncIterator<String>>;
  knockbackGrowth: () => Promise<AsyncIterator<Int>>;
  moveType: () => Promise<AsyncIterator<String>>;
  isWeightDependent: () => Promise<AsyncIterator<Boolean>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface MovesEdge {
  node: Moves;
  cursor: String;
}

export interface MovesEdgePromise extends Promise<MovesEdge>, Fragmentable {
  node: <T = MovesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovesEdgeSubscription
  extends Promise<AsyncIterator<MovesEdge>>,
    Fragmentable {
  node: <T = MovesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharacterConnection {
  pageInfo: PageInfo;
  edges: CharacterEdge[];
}

export interface CharacterConnectionPromise
  extends Promise<CharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterEdge>>() => T;
  aggregate: <T = AggregateCharacterPromise>() => T;
}

export interface CharacterConnectionSubscription
  extends Promise<AsyncIterator<CharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterSubscription>() => T;
}

export interface AggregateMovements {
  count: Int;
}

export interface AggregateMovementsPromise
  extends Promise<AggregateMovements>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovementsSubscription
  extends Promise<AsyncIterator<AggregateMovements>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MovementsConnection {
  pageInfo: PageInfo;
  edges: MovementsEdge[];
}

export interface MovementsConnectionPromise
  extends Promise<MovementsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovementsEdge>>() => T;
  aggregate: <T = AggregateMovementsPromise>() => T;
}

export interface MovementsConnectionSubscription
  extends Promise<AsyncIterator<MovementsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovementsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovementsSubscription>() => T;
}

export interface Movements {
  id: ID_Output;
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface MovementsPromise extends Promise<Movements>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = CharacterPromise>() => T;
  weight: () => Promise<Int>;
  maxJumps: () => Promise<Int>;
  runSpeed: () => Promise<Int>;
  wallJump: () => Promise<Boolean>;
  walkSpeed: () => Promise<Int>;
  wallCling: () => Promise<Boolean>;
  airSpeed: () => Promise<Int>;
  crawl: () => Promise<Boolean>;
  fallSpeed: () => Promise<Int>;
  tether: () => Promise<Boolean>;
  fastFallSpeed: () => Promise<Int>;
  jumpSquat: () => Promise<String>;
  airAcceleration: () => Promise<Int>;
  softLandingLag: () => Promise<String>;
  gravity: () => Promise<Int>;
  hardLandingLag: () => Promise<String>;
  shAirTime: () => Promise<String>;
  fhAirTime: () => Promise<String>;
}

export interface MovementsSubscription
  extends Promise<AsyncIterator<Movements>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = CharacterSubscription>() => T;
  weight: () => Promise<AsyncIterator<Int>>;
  maxJumps: () => Promise<AsyncIterator<Int>>;
  runSpeed: () => Promise<AsyncIterator<Int>>;
  wallJump: () => Promise<AsyncIterator<Boolean>>;
  walkSpeed: () => Promise<AsyncIterator<Int>>;
  wallCling: () => Promise<AsyncIterator<Boolean>>;
  airSpeed: () => Promise<AsyncIterator<Int>>;
  crawl: () => Promise<AsyncIterator<Boolean>>;
  fallSpeed: () => Promise<AsyncIterator<Int>>;
  tether: () => Promise<AsyncIterator<Boolean>>;
  fastFallSpeed: () => Promise<AsyncIterator<Int>>;
  jumpSquat: () => Promise<AsyncIterator<String>>;
  airAcceleration: () => Promise<AsyncIterator<Int>>;
  softLandingLag: () => Promise<AsyncIterator<String>>;
  gravity: () => Promise<AsyncIterator<Int>>;
  hardLandingLag: () => Promise<AsyncIterator<String>>;
  shAirTime: () => Promise<AsyncIterator<String>>;
  fhAirTime: () => Promise<AsyncIterator<String>>;
}

export interface CharacterPreviousValues {
  id: ID_Output;
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export interface CharacterPreviousValuesPromise
  extends Promise<CharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  displayName: () => Promise<String>;
  mainImgUrl: () => Promise<String>;
  thumbnailImg: () => Promise<String>;
  colorTheme: () => Promise<String>;
}

export interface CharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  mainImgUrl: () => Promise<AsyncIterator<String>>;
  thumbnailImg: () => Promise<AsyncIterator<String>>;
  colorTheme: () => Promise<AsyncIterator<String>>;
}

export interface CharacterSubscriptionPayload {
  mutation: MutationType;
  node: Character;
  updatedFields: String[];
  previousValues: CharacterPreviousValues;
}

export interface CharacterSubscriptionPayloadPromise
  extends Promise<CharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterPreviousValuesPromise>() => T;
}

export interface CharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterPreviousValuesSubscription>() => T;
}

export interface MovementsPreviousValues {
  id: ID_Output;
  weight?: Int;
  maxJumps?: Int;
  runSpeed?: Int;
  wallJump?: Boolean;
  walkSpeed?: Int;
  wallCling?: Boolean;
  airSpeed?: Int;
  crawl?: Boolean;
  fallSpeed?: Int;
  tether?: Boolean;
  fastFallSpeed?: Int;
  jumpSquat?: String;
  airAcceleration?: Int;
  softLandingLag?: String;
  gravity?: Int;
  hardLandingLag?: String;
  shAirTime?: String;
  fhAirTime?: String;
}

export interface MovementsPreviousValuesPromise
  extends Promise<MovementsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Int>;
  maxJumps: () => Promise<Int>;
  runSpeed: () => Promise<Int>;
  wallJump: () => Promise<Boolean>;
  walkSpeed: () => Promise<Int>;
  wallCling: () => Promise<Boolean>;
  airSpeed: () => Promise<Int>;
  crawl: () => Promise<Boolean>;
  fallSpeed: () => Promise<Int>;
  tether: () => Promise<Boolean>;
  fastFallSpeed: () => Promise<Int>;
  jumpSquat: () => Promise<String>;
  airAcceleration: () => Promise<Int>;
  softLandingLag: () => Promise<String>;
  gravity: () => Promise<Int>;
  hardLandingLag: () => Promise<String>;
  shAirTime: () => Promise<String>;
  fhAirTime: () => Promise<String>;
}

export interface MovementsPreviousValuesSubscription
  extends Promise<AsyncIterator<MovementsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Int>>;
  maxJumps: () => Promise<AsyncIterator<Int>>;
  runSpeed: () => Promise<AsyncIterator<Int>>;
  wallJump: () => Promise<AsyncIterator<Boolean>>;
  walkSpeed: () => Promise<AsyncIterator<Int>>;
  wallCling: () => Promise<AsyncIterator<Boolean>>;
  airSpeed: () => Promise<AsyncIterator<Int>>;
  crawl: () => Promise<AsyncIterator<Boolean>>;
  fallSpeed: () => Promise<AsyncIterator<Int>>;
  tether: () => Promise<AsyncIterator<Boolean>>;
  fastFallSpeed: () => Promise<AsyncIterator<Int>>;
  jumpSquat: () => Promise<AsyncIterator<String>>;
  airAcceleration: () => Promise<AsyncIterator<Int>>;
  softLandingLag: () => Promise<AsyncIterator<String>>;
  gravity: () => Promise<AsyncIterator<Int>>;
  hardLandingLag: () => Promise<AsyncIterator<String>>;
  shAirTime: () => Promise<AsyncIterator<String>>;
  fhAirTime: () => Promise<AsyncIterator<String>>;
}

export interface MovesSubscriptionPayload {
  mutation: MutationType;
  node: Moves;
  updatedFields: String[];
  previousValues: MovesPreviousValues;
}

export interface MovesSubscriptionPayloadPromise
  extends Promise<MovesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovesPreviousValuesPromise>() => T;
}

export interface MovesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovesPreviousValuesSubscription>() => T;
}

export interface MovementsEdge {
  node: Movements;
  cursor: String;
}

export interface MovementsEdgePromise
  extends Promise<MovementsEdge>,
    Fragmentable {
  node: <T = MovementsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovementsEdgeSubscription
  extends Promise<AsyncIterator<MovementsEdge>>,
    Fragmentable {
  node: <T = MovementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MovesConnection {
  pageInfo: PageInfo;
  edges: MovesEdge[];
}

export interface MovesConnectionPromise
  extends Promise<MovesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovesEdge>>() => T;
  aggregate: <T = AggregateMovesPromise>() => T;
}

export interface MovesConnectionSubscription
  extends Promise<AsyncIterator<MovesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovesSubscription>() => T;
}

export interface AggregateMoves {
  count: Int;
}

export interface AggregateMovesPromise
  extends Promise<AggregateMoves>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovesSubscription
  extends Promise<AsyncIterator<AggregateMoves>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Character",
    embedded: false
  },
  {
    name: "Moves",
    embedded: false
  },
  {
    name: "Movements",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
