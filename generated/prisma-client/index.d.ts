// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  character: (where?: CharacterWhereInput) => Promise<boolean>;
  movements: (where?: MovementsWhereInput) => Promise<boolean>;
  moves: (where?: MovesWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  character: (where: CharacterWhereUniqueInput) => CharacterPromise;
  characters: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Character>;
  charactersConnection: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterConnectionPromise;
  movements: (where: MovementsWhereUniqueInput) => MovementsPromise;
  movementses: (
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Movements>;
  movementsesConnection: (
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MovementsConnectionPromise;
  moves: (where: MovesWhereUniqueInput) => MovesPromise;
  moveses: (
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Moves>;
  movesesConnection: (
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MovesConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharacter: (data: CharacterCreateInput) => CharacterPromise;
  updateCharacter: (
    args: { data: CharacterUpdateInput; where: CharacterWhereUniqueInput }
  ) => CharacterPromise;
  updateManyCharacters: (
    args: {
      data: CharacterUpdateManyMutationInput;
      where?: CharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacter: (
    args: {
      where: CharacterWhereUniqueInput;
      create: CharacterCreateInput;
      update: CharacterUpdateInput;
    }
  ) => CharacterPromise;
  deleteCharacter: (where: CharacterWhereUniqueInput) => CharacterPromise;
  deleteManyCharacters: (where?: CharacterWhereInput) => BatchPayloadPromise;
  createMovements: (data: MovementsCreateInput) => MovementsPromise;
  updateMovements: (
    args: { data: MovementsUpdateInput; where: MovementsWhereUniqueInput }
  ) => MovementsPromise;
  updateManyMovementses: (
    args: {
      data: MovementsUpdateManyMutationInput;
      where?: MovementsWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMovements: (
    args: {
      where: MovementsWhereUniqueInput;
      create: MovementsCreateInput;
      update: MovementsUpdateInput;
    }
  ) => MovementsPromise;
  deleteMovements: (where: MovementsWhereUniqueInput) => MovementsPromise;
  deleteManyMovementses: (where?: MovementsWhereInput) => BatchPayloadPromise;
  createMoves: (data: MovesCreateInput) => MovesPromise;
  updateMoves: (
    args: { data: MovesUpdateInput; where: MovesWhereUniqueInput }
  ) => MovesPromise;
  updateManyMoveses: (
    args: { data: MovesUpdateManyMutationInput; where?: MovesWhereInput }
  ) => BatchPayloadPromise;
  upsertMoves: (
    args: {
      where: MovesWhereUniqueInput;
      create: MovesCreateInput;
      update: MovesUpdateInput;
    }
  ) => MovesPromise;
  deleteMoves: (where: MovesWhereUniqueInput) => MovesPromise;
  deleteManyMoveses: (where?: MovesWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  character: (
    where?: CharacterSubscriptionWhereInput
  ) => CharacterSubscriptionPayloadSubscription;
  movements: (
    where?: MovementsSubscriptionWhereInput
  ) => MovementsSubscriptionPayloadSubscription;
  moves: (
    where?: MovesSubscriptionWhereInput
  ) => MovesSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MovesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "hitBoxActive_ASC"
  | "hitBoxActive_DESC"
  | "firstActionableFrame_ASC"
  | "firstActionableFrame_DESC"
  | "baseDmg_ASC"
  | "baseDmg_DESC"
  | "angle_ASC"
  | "angle_DESC"
  | "baseKnockBackSetKnockback_ASC"
  | "baseKnockBackSetKnockback_DESC"
  | "landingLag_ASC"
  | "landingLag_DESC"
  | "autoCancel_ASC"
  | "autoCancel_DESC"
  | "knockbackGrowth_ASC"
  | "knockbackGrowth_DESC"
  | "moveType_ASC"
  | "moveType_DESC"
  | "isWeightDependent_ASC"
  | "isWeightDependent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MovementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "maxJumps_ASC"
  | "maxJumps_DESC"
  | "wallJump_ASC"
  | "wallJump_DESC"
  | "wallCling_ASC"
  | "wallCling_DESC"
  | "crawl_ASC"
  | "crawl_DESC"
  | "airSpeed_ASC"
  | "airSpeed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "mainImgUrl_ASC"
  | "mainImgUrl_DESC"
  | "thumbnailImg_ASC"
  | "thumbnailImg_DESC"
  | "colorTheme_ASC"
  | "colorTheme_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface MovesUpdateManyWithWhereNestedInput {
  where: MovesScalarWhereInput;
  data: MovesUpdateManyDataInput;
}

export type CharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface MovementsUpdateWithWhereUniqueWithoutUserInput {
  where: MovementsWhereUniqueInput;
  data: MovementsUpdateWithoutUserDataInput;
}

export interface MovementsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: CharacterWhereInput;
  weight?: String;
  weight_not?: String;
  weight_in?: String[] | String;
  weight_not_in?: String[] | String;
  weight_lt?: String;
  weight_lte?: String;
  weight_gt?: String;
  weight_gte?: String;
  weight_contains?: String;
  weight_not_contains?: String;
  weight_starts_with?: String;
  weight_not_starts_with?: String;
  weight_ends_with?: String;
  weight_not_ends_with?: String;
  maxJumps?: String;
  maxJumps_not?: String;
  maxJumps_in?: String[] | String;
  maxJumps_not_in?: String[] | String;
  maxJumps_lt?: String;
  maxJumps_lte?: String;
  maxJumps_gt?: String;
  maxJumps_gte?: String;
  maxJumps_contains?: String;
  maxJumps_not_contains?: String;
  maxJumps_starts_with?: String;
  maxJumps_not_starts_with?: String;
  maxJumps_ends_with?: String;
  maxJumps_not_ends_with?: String;
  wallJump?: String;
  wallJump_not?: String;
  wallJump_in?: String[] | String;
  wallJump_not_in?: String[] | String;
  wallJump_lt?: String;
  wallJump_lte?: String;
  wallJump_gt?: String;
  wallJump_gte?: String;
  wallJump_contains?: String;
  wallJump_not_contains?: String;
  wallJump_starts_with?: String;
  wallJump_not_starts_with?: String;
  wallJump_ends_with?: String;
  wallJump_not_ends_with?: String;
  wallCling?: String;
  wallCling_not?: String;
  wallCling_in?: String[] | String;
  wallCling_not_in?: String[] | String;
  wallCling_lt?: String;
  wallCling_lte?: String;
  wallCling_gt?: String;
  wallCling_gte?: String;
  wallCling_contains?: String;
  wallCling_not_contains?: String;
  wallCling_starts_with?: String;
  wallCling_not_starts_with?: String;
  wallCling_ends_with?: String;
  wallCling_not_ends_with?: String;
  crawl?: String;
  crawl_not?: String;
  crawl_in?: String[] | String;
  crawl_not_in?: String[] | String;
  crawl_lt?: String;
  crawl_lte?: String;
  crawl_gt?: String;
  crawl_gte?: String;
  crawl_contains?: String;
  crawl_not_contains?: String;
  crawl_starts_with?: String;
  crawl_not_starts_with?: String;
  crawl_ends_with?: String;
  crawl_not_ends_with?: String;
  airSpeed?: String;
  airSpeed_not?: String;
  airSpeed_in?: String[] | String;
  airSpeed_not_in?: String[] | String;
  airSpeed_lt?: String;
  airSpeed_lte?: String;
  airSpeed_gt?: String;
  airSpeed_gte?: String;
  airSpeed_contains?: String;
  airSpeed_not_contains?: String;
  airSpeed_starts_with?: String;
  airSpeed_not_starts_with?: String;
  airSpeed_ends_with?: String;
  airSpeed_not_ends_with?: String;
  AND?: MovementsWhereInput[] | MovementsWhereInput;
  OR?: MovementsWhereInput[] | MovementsWhereInput;
  NOT?: MovementsWhereInput[] | MovementsWhereInput;
}

export interface MovementsCreateManyWithoutUserInput {
  create?: MovementsCreateWithoutUserInput[] | MovementsCreateWithoutUserInput;
  connect?: MovementsWhereUniqueInput[] | MovementsWhereUniqueInput;
}

export interface CharacterCreateOneWithoutMovementsInfoInput {
  create?: CharacterCreateWithoutMovementsInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface MovementsCreateWithoutUserInput {
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface MovementsUpdateWithoutUserDataInput {
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface CharacterUpdateInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesUpdateManyWithoutUserInput;
  movementsInfo?: MovementsUpdateManyWithoutUserInput;
}

export interface MovesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: CharacterWhereInput;
  hitBoxActive?: String;
  hitBoxActive_not?: String;
  hitBoxActive_in?: String[] | String;
  hitBoxActive_not_in?: String[] | String;
  hitBoxActive_lt?: String;
  hitBoxActive_lte?: String;
  hitBoxActive_gt?: String;
  hitBoxActive_gte?: String;
  hitBoxActive_contains?: String;
  hitBoxActive_not_contains?: String;
  hitBoxActive_starts_with?: String;
  hitBoxActive_not_starts_with?: String;
  hitBoxActive_ends_with?: String;
  hitBoxActive_not_ends_with?: String;
  firstActionableFrame?: Int;
  firstActionableFrame_not?: Int;
  firstActionableFrame_in?: Int[] | Int;
  firstActionableFrame_not_in?: Int[] | Int;
  firstActionableFrame_lt?: Int;
  firstActionableFrame_lte?: Int;
  firstActionableFrame_gt?: Int;
  firstActionableFrame_gte?: Int;
  baseDmg?: Int;
  baseDmg_not?: Int;
  baseDmg_in?: Int[] | Int;
  baseDmg_not_in?: Int[] | Int;
  baseDmg_lt?: Int;
  baseDmg_lte?: Int;
  baseDmg_gt?: Int;
  baseDmg_gte?: Int;
  angle?: Int;
  angle_not?: Int;
  angle_in?: Int[] | Int;
  angle_not_in?: Int[] | Int;
  angle_lt?: Int;
  angle_lte?: Int;
  angle_gt?: Int;
  angle_gte?: Int;
  baseKnockBackSetKnockback?: Int;
  baseKnockBackSetKnockback_not?: Int;
  baseKnockBackSetKnockback_in?: Int[] | Int;
  baseKnockBackSetKnockback_not_in?: Int[] | Int;
  baseKnockBackSetKnockback_lt?: Int;
  baseKnockBackSetKnockback_lte?: Int;
  baseKnockBackSetKnockback_gt?: Int;
  baseKnockBackSetKnockback_gte?: Int;
  landingLag?: Int;
  landingLag_not?: Int;
  landingLag_in?: Int[] | Int;
  landingLag_not_in?: Int[] | Int;
  landingLag_lt?: Int;
  landingLag_lte?: Int;
  landingLag_gt?: Int;
  landingLag_gte?: Int;
  autoCancel?: String;
  autoCancel_not?: String;
  autoCancel_in?: String[] | String;
  autoCancel_not_in?: String[] | String;
  autoCancel_lt?: String;
  autoCancel_lte?: String;
  autoCancel_gt?: String;
  autoCancel_gte?: String;
  autoCancel_contains?: String;
  autoCancel_not_contains?: String;
  autoCancel_starts_with?: String;
  autoCancel_not_starts_with?: String;
  autoCancel_ends_with?: String;
  autoCancel_not_ends_with?: String;
  knockbackGrowth?: Int;
  knockbackGrowth_not?: Int;
  knockbackGrowth_in?: Int[] | Int;
  knockbackGrowth_not_in?: Int[] | Int;
  knockbackGrowth_lt?: Int;
  knockbackGrowth_lte?: Int;
  knockbackGrowth_gt?: Int;
  knockbackGrowth_gte?: Int;
  moveType?: String;
  moveType_not?: String;
  moveType_in?: String[] | String;
  moveType_not_in?: String[] | String;
  moveType_lt?: String;
  moveType_lte?: String;
  moveType_gt?: String;
  moveType_gte?: String;
  moveType_contains?: String;
  moveType_not_contains?: String;
  moveType_starts_with?: String;
  moveType_not_starts_with?: String;
  moveType_ends_with?: String;
  moveType_not_ends_with?: String;
  isWeightDependent?: Boolean;
  isWeightDependent_not?: Boolean;
  AND?: MovesWhereInput[] | MovesWhereInput;
  OR?: MovesWhereInput[] | MovesWhereInput;
  NOT?: MovesWhereInput[] | MovesWhereInput;
}

export interface MovesUpdateManyWithoutUserInput {
  create?: MovesCreateWithoutUserInput[] | MovesCreateWithoutUserInput;
  delete?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  connect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  set?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  disconnect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
  update?:
    | MovesUpdateWithWhereUniqueWithoutUserInput[]
    | MovesUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | MovesUpsertWithWhereUniqueWithoutUserInput[]
    | MovesUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  updateMany?:
    | MovesUpdateManyWithWhereNestedInput[]
    | MovesUpdateManyWithWhereNestedInput;
}

export interface CharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterWhereInput;
  AND?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  OR?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  NOT?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
}

export interface MovesUpdateWithWhereUniqueWithoutUserInput {
  where: MovesWhereUniqueInput;
  data: MovesUpdateWithoutUserDataInput;
}

export interface CharacterUpsertWithoutMoveInfoInput {
  update: CharacterUpdateWithoutMoveInfoDataInput;
  create: CharacterCreateWithoutMoveInfoInput;
}

export interface MovesUpdateWithoutUserDataInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface CharacterUpdateOneRequiredWithoutMoveInfoInput {
  create?: CharacterCreateWithoutMoveInfoInput;
  update?: CharacterUpdateWithoutMoveInfoDataInput;
  upsert?: CharacterUpsertWithoutMoveInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface MovesUpsertWithWhereUniqueWithoutUserInput {
  where: MovesWhereUniqueInput;
  update: MovesUpdateWithoutUserDataInput;
  create: MovesCreateWithoutUserInput;
}

export interface MovesUpdateInput {
  name?: String;
  user?: CharacterUpdateOneRequiredWithoutMoveInfoInput;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  hitBoxActive?: String;
  hitBoxActive_not?: String;
  hitBoxActive_in?: String[] | String;
  hitBoxActive_not_in?: String[] | String;
  hitBoxActive_lt?: String;
  hitBoxActive_lte?: String;
  hitBoxActive_gt?: String;
  hitBoxActive_gte?: String;
  hitBoxActive_contains?: String;
  hitBoxActive_not_contains?: String;
  hitBoxActive_starts_with?: String;
  hitBoxActive_not_starts_with?: String;
  hitBoxActive_ends_with?: String;
  hitBoxActive_not_ends_with?: String;
  firstActionableFrame?: Int;
  firstActionableFrame_not?: Int;
  firstActionableFrame_in?: Int[] | Int;
  firstActionableFrame_not_in?: Int[] | Int;
  firstActionableFrame_lt?: Int;
  firstActionableFrame_lte?: Int;
  firstActionableFrame_gt?: Int;
  firstActionableFrame_gte?: Int;
  baseDmg?: Int;
  baseDmg_not?: Int;
  baseDmg_in?: Int[] | Int;
  baseDmg_not_in?: Int[] | Int;
  baseDmg_lt?: Int;
  baseDmg_lte?: Int;
  baseDmg_gt?: Int;
  baseDmg_gte?: Int;
  angle?: Int;
  angle_not?: Int;
  angle_in?: Int[] | Int;
  angle_not_in?: Int[] | Int;
  angle_lt?: Int;
  angle_lte?: Int;
  angle_gt?: Int;
  angle_gte?: Int;
  baseKnockBackSetKnockback?: Int;
  baseKnockBackSetKnockback_not?: Int;
  baseKnockBackSetKnockback_in?: Int[] | Int;
  baseKnockBackSetKnockback_not_in?: Int[] | Int;
  baseKnockBackSetKnockback_lt?: Int;
  baseKnockBackSetKnockback_lte?: Int;
  baseKnockBackSetKnockback_gt?: Int;
  baseKnockBackSetKnockback_gte?: Int;
  landingLag?: Int;
  landingLag_not?: Int;
  landingLag_in?: Int[] | Int;
  landingLag_not_in?: Int[] | Int;
  landingLag_lt?: Int;
  landingLag_lte?: Int;
  landingLag_gt?: Int;
  landingLag_gte?: Int;
  autoCancel?: String;
  autoCancel_not?: String;
  autoCancel_in?: String[] | String;
  autoCancel_not_in?: String[] | String;
  autoCancel_lt?: String;
  autoCancel_lte?: String;
  autoCancel_gt?: String;
  autoCancel_gte?: String;
  autoCancel_contains?: String;
  autoCancel_not_contains?: String;
  autoCancel_starts_with?: String;
  autoCancel_not_starts_with?: String;
  autoCancel_ends_with?: String;
  autoCancel_not_ends_with?: String;
  knockbackGrowth?: Int;
  knockbackGrowth_not?: Int;
  knockbackGrowth_in?: Int[] | Int;
  knockbackGrowth_not_in?: Int[] | Int;
  knockbackGrowth_lt?: Int;
  knockbackGrowth_lte?: Int;
  knockbackGrowth_gt?: Int;
  knockbackGrowth_gte?: Int;
  moveType?: String;
  moveType_not?: String;
  moveType_in?: String[] | String;
  moveType_not_in?: String[] | String;
  moveType_lt?: String;
  moveType_lte?: String;
  moveType_gt?: String;
  moveType_gte?: String;
  moveType_contains?: String;
  moveType_not_contains?: String;
  moveType_starts_with?: String;
  moveType_not_starts_with?: String;
  moveType_ends_with?: String;
  moveType_not_ends_with?: String;
  isWeightDependent?: Boolean;
  isWeightDependent_not?: Boolean;
  AND?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  OR?: MovesScalarWhereInput[] | MovesScalarWhereInput;
  NOT?: MovesScalarWhereInput[] | MovesScalarWhereInput;
}

export interface CharacterCreateOneWithoutMoveInfoInput {
  create?: CharacterCreateWithoutMoveInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface CharacterUpdateWithoutMovementsInfoDataInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesUpdateManyWithoutUserInput;
}

export interface MovesCreateInput {
  name: String;
  user: CharacterCreateOneWithoutMoveInfoInput;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesUpdateManyDataInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface CharacterUpsertWithoutMovementsInfoInput {
  update: CharacterUpdateWithoutMovementsInfoDataInput;
  create: CharacterCreateWithoutMovementsInfoInput;
}

export interface MovementsUpdateManyWithoutUserInput {
  create?: MovementsCreateWithoutUserInput[] | MovementsCreateWithoutUserInput;
  delete?: MovementsWhereUniqueInput[] | MovementsWhereUniqueInput;
  connect?: MovementsWhereUniqueInput[] | MovementsWhereUniqueInput;
  set?: MovementsWhereUniqueInput[] | MovementsWhereUniqueInput;
  disconnect?: MovementsWhereUniqueInput[] | MovementsWhereUniqueInput;
  update?:
    | MovementsUpdateWithWhereUniqueWithoutUserInput[]
    | MovementsUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | MovementsUpsertWithWhereUniqueWithoutUserInput[]
    | MovementsUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: MovementsScalarWhereInput[] | MovementsScalarWhereInput;
  updateMany?:
    | MovementsUpdateManyWithWhereNestedInput[]
    | MovementsUpdateManyWithWhereNestedInput;
}

export interface CharacterCreateInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesCreateManyWithoutUserInput;
  movementsInfo?: MovementsCreateManyWithoutUserInput;
}

export interface CharacterUpdateOneRequiredWithoutMovementsInfoInput {
  create?: CharacterCreateWithoutMovementsInfoInput;
  update?: CharacterUpdateWithoutMovementsInfoDataInput;
  upsert?: CharacterUpsertWithoutMovementsInfoInput;
  connect?: CharacterWhereUniqueInput;
}

export interface MovesCreateWithoutUserInput {
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface CharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  displayName?: String;
  displayName_not?: String;
  displayName_in?: String[] | String;
  displayName_not_in?: String[] | String;
  displayName_lt?: String;
  displayName_lte?: String;
  displayName_gt?: String;
  displayName_gte?: String;
  displayName_contains?: String;
  displayName_not_contains?: String;
  displayName_starts_with?: String;
  displayName_not_starts_with?: String;
  displayName_ends_with?: String;
  displayName_not_ends_with?: String;
  mainImgUrl?: String;
  mainImgUrl_not?: String;
  mainImgUrl_in?: String[] | String;
  mainImgUrl_not_in?: String[] | String;
  mainImgUrl_lt?: String;
  mainImgUrl_lte?: String;
  mainImgUrl_gt?: String;
  mainImgUrl_gte?: String;
  mainImgUrl_contains?: String;
  mainImgUrl_not_contains?: String;
  mainImgUrl_starts_with?: String;
  mainImgUrl_not_starts_with?: String;
  mainImgUrl_ends_with?: String;
  mainImgUrl_not_ends_with?: String;
  thumbnailImg?: String;
  thumbnailImg_not?: String;
  thumbnailImg_in?: String[] | String;
  thumbnailImg_not_in?: String[] | String;
  thumbnailImg_lt?: String;
  thumbnailImg_lte?: String;
  thumbnailImg_gt?: String;
  thumbnailImg_gte?: String;
  thumbnailImg_contains?: String;
  thumbnailImg_not_contains?: String;
  thumbnailImg_starts_with?: String;
  thumbnailImg_not_starts_with?: String;
  thumbnailImg_ends_with?: String;
  thumbnailImg_not_ends_with?: String;
  colorTheme?: String;
  colorTheme_not?: String;
  colorTheme_in?: String[] | String;
  colorTheme_not_in?: String[] | String;
  colorTheme_lt?: String;
  colorTheme_lte?: String;
  colorTheme_gt?: String;
  colorTheme_gte?: String;
  colorTheme_contains?: String;
  colorTheme_not_contains?: String;
  colorTheme_starts_with?: String;
  colorTheme_not_starts_with?: String;
  colorTheme_ends_with?: String;
  colorTheme_not_ends_with?: String;
  moveInfo_every?: MovesWhereInput;
  moveInfo_some?: MovesWhereInput;
  moveInfo_none?: MovesWhereInput;
  movementsInfo_every?: MovementsWhereInput;
  movementsInfo_some?: MovementsWhereInput;
  movementsInfo_none?: MovementsWhereInput;
  AND?: CharacterWhereInput[] | CharacterWhereInput;
  OR?: CharacterWhereInput[] | CharacterWhereInput;
  NOT?: CharacterWhereInput[] | CharacterWhereInput;
}

export interface MovementsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MovementsWhereInput;
  AND?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
  OR?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
  NOT?: MovementsSubscriptionWhereInput[] | MovementsSubscriptionWhereInput;
}

export interface MovementsUpsertWithWhereUniqueWithoutUserInput {
  where: MovementsWhereUniqueInput;
  update: MovementsUpdateWithoutUserDataInput;
  create: MovementsCreateWithoutUserInput;
}

export interface CharacterUpdateWithoutMoveInfoDataInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  movementsInfo?: MovementsUpdateManyWithoutUserInput;
}

export interface MovementsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weight?: String;
  weight_not?: String;
  weight_in?: String[] | String;
  weight_not_in?: String[] | String;
  weight_lt?: String;
  weight_lte?: String;
  weight_gt?: String;
  weight_gte?: String;
  weight_contains?: String;
  weight_not_contains?: String;
  weight_starts_with?: String;
  weight_not_starts_with?: String;
  weight_ends_with?: String;
  weight_not_ends_with?: String;
  maxJumps?: String;
  maxJumps_not?: String;
  maxJumps_in?: String[] | String;
  maxJumps_not_in?: String[] | String;
  maxJumps_lt?: String;
  maxJumps_lte?: String;
  maxJumps_gt?: String;
  maxJumps_gte?: String;
  maxJumps_contains?: String;
  maxJumps_not_contains?: String;
  maxJumps_starts_with?: String;
  maxJumps_not_starts_with?: String;
  maxJumps_ends_with?: String;
  maxJumps_not_ends_with?: String;
  wallJump?: String;
  wallJump_not?: String;
  wallJump_in?: String[] | String;
  wallJump_not_in?: String[] | String;
  wallJump_lt?: String;
  wallJump_lte?: String;
  wallJump_gt?: String;
  wallJump_gte?: String;
  wallJump_contains?: String;
  wallJump_not_contains?: String;
  wallJump_starts_with?: String;
  wallJump_not_starts_with?: String;
  wallJump_ends_with?: String;
  wallJump_not_ends_with?: String;
  wallCling?: String;
  wallCling_not?: String;
  wallCling_in?: String[] | String;
  wallCling_not_in?: String[] | String;
  wallCling_lt?: String;
  wallCling_lte?: String;
  wallCling_gt?: String;
  wallCling_gte?: String;
  wallCling_contains?: String;
  wallCling_not_contains?: String;
  wallCling_starts_with?: String;
  wallCling_not_starts_with?: String;
  wallCling_ends_with?: String;
  wallCling_not_ends_with?: String;
  crawl?: String;
  crawl_not?: String;
  crawl_in?: String[] | String;
  crawl_not_in?: String[] | String;
  crawl_lt?: String;
  crawl_lte?: String;
  crawl_gt?: String;
  crawl_gte?: String;
  crawl_contains?: String;
  crawl_not_contains?: String;
  crawl_starts_with?: String;
  crawl_not_starts_with?: String;
  crawl_ends_with?: String;
  crawl_not_ends_with?: String;
  airSpeed?: String;
  airSpeed_not?: String;
  airSpeed_in?: String[] | String;
  airSpeed_not_in?: String[] | String;
  airSpeed_lt?: String;
  airSpeed_lte?: String;
  airSpeed_gt?: String;
  airSpeed_gte?: String;
  airSpeed_contains?: String;
  airSpeed_not_contains?: String;
  airSpeed_starts_with?: String;
  airSpeed_not_starts_with?: String;
  airSpeed_ends_with?: String;
  airSpeed_not_ends_with?: String;
  AND?: MovementsScalarWhereInput[] | MovementsScalarWhereInput;
  OR?: MovementsScalarWhereInput[] | MovementsScalarWhereInput;
  NOT?: MovementsScalarWhereInput[] | MovementsScalarWhereInput;
}

export interface CharacterCreateWithoutMoveInfoInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  movementsInfo?: MovementsCreateManyWithoutUserInput;
}

export interface MovementsUpdateManyWithWhereNestedInput {
  where: MovementsScalarWhereInput;
  data: MovementsUpdateManyDataInput;
}

export interface MovementsUpdateManyMutationInput {
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface MovementsUpdateManyDataInput {
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface MovesCreateManyWithoutUserInput {
  create?: MovesCreateWithoutUserInput[] | MovesCreateWithoutUserInput;
  connect?: MovesWhereUniqueInput[] | MovesWhereUniqueInput;
}

export interface MovesUpdateManyMutationInput {
  name?: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovementsCreateInput {
  user: CharacterCreateOneWithoutMovementsInfoInput;
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface CharacterCreateWithoutMovementsInfoInput {
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
  moveInfo?: MovesCreateManyWithoutUserInput;
}

export interface MovementsUpdateInput {
  user?: CharacterUpdateOneRequiredWithoutMovementsInfoInput;
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface CharacterUpdateManyMutationInput {
  name?: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export type MovementsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MovesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MovesWhereInput;
  AND?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
  OR?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
  NOT?: MovesSubscriptionWhereInput[] | MovesSubscriptionWhereInput;
}

export type MovesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface MovesPreviousValues {
  id: ID_Output;
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesPreviousValuesPromise
  extends Promise<MovesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hitBoxActive: () => Promise<String>;
  firstActionableFrame: () => Promise<Int>;
  baseDmg: () => Promise<Int>;
  angle: () => Promise<Int>;
  baseKnockBackSetKnockback: () => Promise<Int>;
  landingLag: () => Promise<Int>;
  autoCancel: () => Promise<String>;
  knockbackGrowth: () => Promise<Int>;
  moveType: () => Promise<String>;
  isWeightDependent: () => Promise<Boolean>;
}

export interface MovesPreviousValuesSubscription
  extends Promise<AsyncIterator<MovesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hitBoxActive: () => Promise<AsyncIterator<String>>;
  firstActionableFrame: () => Promise<AsyncIterator<Int>>;
  baseDmg: () => Promise<AsyncIterator<Int>>;
  angle: () => Promise<AsyncIterator<Int>>;
  baseKnockBackSetKnockback: () => Promise<AsyncIterator<Int>>;
  landingLag: () => Promise<AsyncIterator<Int>>;
  autoCancel: () => Promise<AsyncIterator<String>>;
  knockbackGrowth: () => Promise<AsyncIterator<Int>>;
  moveType: () => Promise<AsyncIterator<String>>;
  isWeightDependent: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateCharacter {
  count: Int;
}

export interface AggregateCharacterPromise
  extends Promise<AggregateCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterSubscription
  extends Promise<AsyncIterator<AggregateCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MovementsSubscriptionPayload {
  mutation: MutationType;
  node: Movements;
  updatedFields: String[];
  previousValues: MovementsPreviousValues;
}

export interface MovementsSubscriptionPayloadPromise
  extends Promise<MovementsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovementsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovementsPreviousValuesPromise>() => T;
}

export interface MovementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovementsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovementsPreviousValuesSubscription>() => T;
}

export interface CharacterEdge {
  node: Character;
  cursor: String;
}

export interface CharacterEdgePromise
  extends Promise<CharacterEdge>,
    Fragmentable {
  node: <T = CharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterEdgeSubscription
  extends Promise<AsyncIterator<CharacterEdge>>,
    Fragmentable {
  node: <T = CharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Moves {
  id: ID_Output;
  name: String;
  hitBoxActive?: String;
  firstActionableFrame?: Int;
  baseDmg?: Int;
  angle?: Int;
  baseKnockBackSetKnockback?: Int;
  landingLag?: Int;
  autoCancel?: String;
  knockbackGrowth?: Int;
  moveType?: String;
  isWeightDependent?: Boolean;
}

export interface MovesPromise extends Promise<Moves>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  user: <T = CharacterPromise>() => T;
  hitBoxActive: () => Promise<String>;
  firstActionableFrame: () => Promise<Int>;
  baseDmg: () => Promise<Int>;
  angle: () => Promise<Int>;
  baseKnockBackSetKnockback: () => Promise<Int>;
  landingLag: () => Promise<Int>;
  autoCancel: () => Promise<String>;
  knockbackGrowth: () => Promise<Int>;
  moveType: () => Promise<String>;
  isWeightDependent: () => Promise<Boolean>;
}

export interface MovesSubscription
  extends Promise<AsyncIterator<Moves>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = CharacterSubscription>() => T;
  hitBoxActive: () => Promise<AsyncIterator<String>>;
  firstActionableFrame: () => Promise<AsyncIterator<Int>>;
  baseDmg: () => Promise<AsyncIterator<Int>>;
  angle: () => Promise<AsyncIterator<Int>>;
  baseKnockBackSetKnockback: () => Promise<AsyncIterator<Int>>;
  landingLag: () => Promise<AsyncIterator<Int>>;
  autoCancel: () => Promise<AsyncIterator<String>>;
  knockbackGrowth: () => Promise<AsyncIterator<Int>>;
  moveType: () => Promise<AsyncIterator<String>>;
  isWeightDependent: () => Promise<AsyncIterator<Boolean>>;
}

export interface CharacterConnection {
  pageInfo: PageInfo;
  edges: CharacterEdge[];
}

export interface CharacterConnectionPromise
  extends Promise<CharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterEdge>>() => T;
  aggregate: <T = AggregateCharacterPromise>() => T;
}

export interface CharacterConnectionSubscription
  extends Promise<AsyncIterator<CharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterSubscription>() => T;
}

export interface MovesEdge {
  node: Moves;
  cursor: String;
}

export interface MovesEdgePromise extends Promise<MovesEdge>, Fragmentable {
  node: <T = MovesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovesEdgeSubscription
  extends Promise<AsyncIterator<MovesEdge>>,
    Fragmentable {
  node: <T = MovesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Character {
  id: ID_Output;
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export interface CharacterPromise extends Promise<Character>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  displayName: () => Promise<String>;
  mainImgUrl: () => Promise<String>;
  thumbnailImg: () => Promise<String>;
  colorTheme: () => Promise<String>;
  moveInfo: <T = FragmentableArray<Moves>>(
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  movementsInfo: <T = FragmentableArray<Movements>>(
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharacterSubscription
  extends Promise<AsyncIterator<Character>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  mainImgUrl: () => Promise<AsyncIterator<String>>;
  thumbnailImg: () => Promise<AsyncIterator<String>>;
  colorTheme: () => Promise<AsyncIterator<String>>;
  moveInfo: <T = Promise<AsyncIterator<MovesSubscription>>>(
    args?: {
      where?: MovesWhereInput;
      orderBy?: MovesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  movementsInfo: <T = Promise<AsyncIterator<MovementsSubscription>>>(
    args?: {
      where?: MovementsWhereInput;
      orderBy?: MovementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateMovements {
  count: Int;
}

export interface AggregateMovementsPromise
  extends Promise<AggregateMovements>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovementsSubscription
  extends Promise<AsyncIterator<AggregateMovements>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MovementsConnection {
  pageInfo: PageInfo;
  edges: MovementsEdge[];
}

export interface MovementsConnectionPromise
  extends Promise<MovementsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovementsEdge>>() => T;
  aggregate: <T = AggregateMovementsPromise>() => T;
}

export interface MovementsConnectionSubscription
  extends Promise<AsyncIterator<MovementsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovementsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovementsSubscription>() => T;
}

export interface Movements {
  id: ID_Output;
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface MovementsPromise extends Promise<Movements>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = CharacterPromise>() => T;
  weight: () => Promise<String>;
  maxJumps: () => Promise<String>;
  wallJump: () => Promise<String>;
  wallCling: () => Promise<String>;
  crawl: () => Promise<String>;
  airSpeed: () => Promise<String>;
}

export interface MovementsSubscription
  extends Promise<AsyncIterator<Movements>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = CharacterSubscription>() => T;
  weight: () => Promise<AsyncIterator<String>>;
  maxJumps: () => Promise<AsyncIterator<String>>;
  wallJump: () => Promise<AsyncIterator<String>>;
  wallCling: () => Promise<AsyncIterator<String>>;
  crawl: () => Promise<AsyncIterator<String>>;
  airSpeed: () => Promise<AsyncIterator<String>>;
}

export interface CharacterPreviousValues {
  id: ID_Output;
  name: String;
  displayName?: String;
  mainImgUrl?: String;
  thumbnailImg?: String;
  colorTheme?: String;
}

export interface CharacterPreviousValuesPromise
  extends Promise<CharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  displayName: () => Promise<String>;
  mainImgUrl: () => Promise<String>;
  thumbnailImg: () => Promise<String>;
  colorTheme: () => Promise<String>;
}

export interface CharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  mainImgUrl: () => Promise<AsyncIterator<String>>;
  thumbnailImg: () => Promise<AsyncIterator<String>>;
  colorTheme: () => Promise<AsyncIterator<String>>;
}

export interface CharacterSubscriptionPayload {
  mutation: MutationType;
  node: Character;
  updatedFields: String[];
  previousValues: CharacterPreviousValues;
}

export interface CharacterSubscriptionPayloadPromise
  extends Promise<CharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterPreviousValuesPromise>() => T;
}

export interface CharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterPreviousValuesSubscription>() => T;
}

export interface MovementsPreviousValues {
  id: ID_Output;
  weight?: String;
  maxJumps?: String;
  wallJump?: String;
  wallCling?: String;
  crawl?: String;
  airSpeed?: String;
}

export interface MovementsPreviousValuesPromise
  extends Promise<MovementsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<String>;
  maxJumps: () => Promise<String>;
  wallJump: () => Promise<String>;
  wallCling: () => Promise<String>;
  crawl: () => Promise<String>;
  airSpeed: () => Promise<String>;
}

export interface MovementsPreviousValuesSubscription
  extends Promise<AsyncIterator<MovementsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<String>>;
  maxJumps: () => Promise<AsyncIterator<String>>;
  wallJump: () => Promise<AsyncIterator<String>>;
  wallCling: () => Promise<AsyncIterator<String>>;
  crawl: () => Promise<AsyncIterator<String>>;
  airSpeed: () => Promise<AsyncIterator<String>>;
}

export interface MovesSubscriptionPayload {
  mutation: MutationType;
  node: Moves;
  updatedFields: String[];
  previousValues: MovesPreviousValues;
}

export interface MovesSubscriptionPayloadPromise
  extends Promise<MovesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovesPreviousValuesPromise>() => T;
}

export interface MovesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovesPreviousValuesSubscription>() => T;
}

export interface MovementsEdge {
  node: Movements;
  cursor: String;
}

export interface MovementsEdgePromise
  extends Promise<MovementsEdge>,
    Fragmentable {
  node: <T = MovementsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovementsEdgeSubscription
  extends Promise<AsyncIterator<MovementsEdge>>,
    Fragmentable {
  node: <T = MovementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MovesConnection {
  pageInfo: PageInfo;
  edges: MovesEdge[];
}

export interface MovesConnectionPromise
  extends Promise<MovesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovesEdge>>() => T;
  aggregate: <T = AggregateMovesPromise>() => T;
}

export interface MovesConnectionSubscription
  extends Promise<AsyncIterator<MovesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovesSubscription>() => T;
}

export interface AggregateMoves {
  count: Int;
}

export interface AggregateMovesPromise
  extends Promise<AggregateMoves>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovesSubscription
  extends Promise<AsyncIterator<AggregateMoves>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Character",
    embedded: false
  },
  {
    name: "Moves",
    embedded: false
  },
  {
    name: "Movements",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
